"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preset = exports.resolveDocumentImports = void 0;
var path_1 = require("path");
var add_1 = __importDefault(require("@graphql-codegen/add"));
var graphql_1 = require("graphql");
var env_1 = require("./directive/env");
var injectable_1 = require("./directive/injectable");
var resolve_document_imports_1 = require("./resolve-document-imports");
Object.defineProperty(exports, "resolveDocumentImports", { enumerable: true, get: function () { return resolve_document_imports_1.resolveDocumentImports; } });
var utils_1 = require("./utils");
function isFragment(documentFile) {
    var name = false;
    if (!documentFile.document)
        return name;
    (0, graphql_1.visit)(documentFile.document, {
        FragmentDefinition: function () {
            name = true;
        },
    });
    return name;
}
function isDocument(documentFiles) {
    return !documentFiles.every(isFragment);
}
exports.preset = {
    buildGeneratesSection: function (options) {
        var _a, _b, _c, _d, _e, _f;
        options.documents = (0, env_1.envDirective)(options.documents);
        if (options.presetConfig.injectables) {
            options.documents = (0, injectable_1.injectableDirective)(options.documents);
        }
        var schemaObject = (_a = options.schemaAst) !== null && _a !== void 0 ? _a : (0, graphql_1.buildASTSchema)(options.schema, options.config);
        var baseDir = (_b = options.presetConfig.cwd) !== null && _b !== void 0 ? _b : process.cwd();
        var extension = (_c = options.presetConfig.extension) !== null && _c !== void 0 ? _c : '.generated.ts';
        var folder = (_d = options.presetConfig.folder) !== null && _d !== void 0 ? _d : '';
        var importTypesNamespace = (_e = options.presetConfig.importTypesNamespace) !== null && _e !== void 0 ? _e : 'Types';
        var importAllFragmentsFrom = options.presetConfig.importAllFragmentsFrom;
        var baseTypesPath = options.presetConfig.baseTypesPath;
        if (!baseTypesPath) {
            throw new Error("Preset \"near-operation-file\" requires you to specify \"baseTypesPath\" configuration and point it to your base types file (generated by \"typescript\" plugin)!");
        }
        var shouldAbsolute = !baseTypesPath.startsWith('~');
        var pluginMap = __assign(__assign({}, options.pluginMap), { add: add_1.default });
        var sources = (0, resolve_document_imports_1.resolveDocumentImports)(options, schemaObject, {
            baseDir: baseDir,
            generateFilePath: function (location) {
                var newFilePath = (0, utils_1.defineFilepathSubfolder)(location, folder);
                return (0, utils_1.appendExtensionToFilePath)(newFilePath, extension);
            },
            schemaTypesSource: {
                path: shouldAbsolute ? (0, path_1.join)(options.baseOutputDir, baseTypesPath) : baseTypesPath,
                namespace: importTypesNamespace,
            },
            typesImport: (_f = options.config.useTypeImports) !== null && _f !== void 0 ? _f : false,
        });
        return sources.map(function (_a) {
            var importStatements = _a.importStatements, externalFragments = _a.externalFragments, fragmentImports = _a.fragmentImports, documents = _a.documents, source = __rest(_a, ["importStatements", "externalFragments", "fragmentImports", "documents"]);
            var fragmentImportsArr = fragmentImports;
            if (importAllFragmentsFrom) {
                fragmentImportsArr = fragmentImports.map(function (t) {
                    var newImportSource = typeof importAllFragmentsFrom === 'string'
                        ? __assign(__assign({}, t.importSource), { path: importAllFragmentsFrom }) : importAllFragmentsFrom(t.importSource, source.filename);
                    return __assign(__assign({}, t), { importSource: newImportSource || t.importSource });
                });
            }
            var isDoc = isDocument(documents);
            var isRelayOptimizer = !!Object.keys(pluginMap).find(function (plugin) {
                return plugin.includes('relay-optimizer-plugin');
            });
            var plugins = __spreadArray(__spreadArray([], (options.config.globalNamespace
                ? []
                : importStatements.map(function (importStatement) { return ({ add: { content: importStatement } }); })), true), options.plugins.filter(function (pluginOptions) {
                return !isRelayOptimizer ||
                    isDoc ||
                    !Object.keys(pluginOptions).includes('typed-document-node');
            }), true);
            var config = __assign(__assign({}, options.config), { 
                // This is set here in order to make sure the fragment spreads sub types
                // are exported from operations file
                exportFragmentSpreadSubTypes: true, namespacedImportName: importTypesNamespace, externalFragments: externalFragments, fragmentImports: fragmentImportsArr });
            return __assign(__assign({}, source), { documents: documents, plugins: plugins, pluginMap: pluginMap, config: config, schema: options.schema, schemaAst: schemaObject, skipDocumentsValidation: true });
        });
    },
};
exports.default = exports.preset;
