"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateInterceptors = exports.generateInterceptor = void 0;
const node_path_1 = __importDefault(require("node:path"));
function moveRelativeDown(plugins) {
    return [...plugins].sort((a, b) => {
        if (a.plugin.startsWith('.') && !b.plugin.startsWith('.'))
            return 1;
        if (!a.plugin.startsWith('.') && b.plugin.startsWith('.'))
            return -1;
        return 0;
    });
}
function generateInterceptor(interceptor) {
    const { fromModule, dependency, components } = interceptor;
    const flattended = Object.entries(components)
        .map(([, plugins]) => plugins)
        .flat();
    const duplicateImports = new Set();
    const pluginImports = moveRelativeDown([...flattended].sort((a, b) => a.plugin.localeCompare(b.plugin)))
        .map((p) => p.plugin)
        .map((p) => `import { Plugin as ${p.split('/')[p.split('/').length - 1]} } from '${p}'`)
        .filter((str) => {
        if (duplicateImports.has(str))
            return false;
        duplicateImports.add(str);
        return true;
    })
        .join('\n');
    const imports = Object.entries(components).map(([component]) => `${component} as ${component}Base`);
    const importInjectables = imports.length > 1
        ? `import { 
  ${imports.join(',\n  ')},
} from '${fromModule}'`
        : `import { ${imports[0]} } from '${fromModule}'`;
    const pluginExports = Object.entries(components)
        .map(([component, plugins]) => {
        const duplicateInterceptors = new Set();
        let carry = `${component}Base`;
        const pluginStr = plugins
            .reverse()
            .map((p) => p.plugin.split('/')[p.plugin.split('/').length - 1])
            .filter((importStr) => {
            if (duplicateInterceptors.has(importStr)) {
                return false;
            }
            duplicateInterceptors.add(importStr);
            return true;
        })
            .map((name) => {
            const result = `function ${name}Interceptor(props: ${component}Props) {
  return <${name} {...props} Prev={${carry}} />
}`;
            carry = `${name}Interceptor`;
            return result;
        })
            .join('\n');
        return `
/**
 * Interceptor for \`<${component}/>\` with these plugins:
 * 
${plugins.map((p) => ` * - \`${p.plugin}\``).join('\n')}
 */
type ${component}Props = ComponentProps<typeof ${component}Base>

${pluginStr}
export const ${component} = ${carry}`;
    })
        .join('\n');
    const componentExports = `export * from '${fromModule}'`;
    const template = `/* This file is automatically generated for ${dependency} */

${componentExports}
${pluginImports}
import { ComponentProps } from 'react'
${importInjectables}
${pluginExports}
`;
    return { ...interceptor, template };
}
exports.generateInterceptor = generateInterceptor;
function generateInterceptors(plugins, resolve) {
    // todo: Do not use reduce as we're passing the accumulator to the next iteration
    const byExportedComponent = moveRelativeDown(plugins).reduce((acc, plug) => {
        const { exported, component, enabled, plugin } = plug;
        if (!exported || !component || !enabled)
            return acc;
        const resolved = resolve(exported);
        let pluginPathFromResolved = plugin;
        if (plugin.startsWith('.')) {
            const resolvedPlugin = resolve(plugin);
            pluginPathFromResolved = node_path_1.default.relative(resolved.root, resolvedPlugin.fromRoot);
        }
        if (!acc[resolved.fromRoot])
            acc[resolved.fromRoot] = {
                ...resolved,
                target: `${resolved.fromRoot}.interceptor`,
                components: {},
            };
        if (!acc[resolved.fromRoot].components[component])
            acc[resolved.fromRoot].components[component] = [];
        acc[resolved.fromRoot].components[component].push({
            ...plug,
            plugin: pluginPathFromResolved,
        });
        return acc;
    }, {});
    return Object.fromEntries(Object.entries(byExportedComponent).map(([target, interceptor]) => [
        target,
        generateInterceptor(interceptor),
    ]));
}
exports.generateInterceptors = generateInterceptors;
